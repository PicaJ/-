计算机系统：
	type *x = a：	//a为数值类型变量
		（x的地址不是a的地址）
		*x表示为指向的值（操作数为指向值，作参数传入时，传值的拷贝）；
		&x表示为指针x的地址（操作数为地址值，作参数传入时，作地址的拷贝）；
		x+1/x[i]表示为地址的下一个数据单元（当为单字节指针时表示下一个字节地址）；
		
	type *x;
	x = &a;
		（x的地址为a的地址）
		x表示为指向的值（操作数为指向值，作参数传入时，传值的拷贝）；
		&x表示为变量a的地址（操作数为地址值，作参数传入时，作地址的拷贝）；
		x+1/x[i]表示为地址的下一个数据单元（当为单字节指针时表示下一个字节地址）；
	
	--------------------------------------------------------------------------------------------上述待修改，有错误
	每种数据类型都有它的字节长度;
		同时，每种数据类型都按其字节位表示数值	
		//int ：01 	00 	00 	00 （在小端机器上，int 1的地址分配表示的数值）（单字节表示）
		地址	0x01 0x02 0x03 0x04
		
	每个类型变量都有它的起始地址和字节长度;
	
	&x 表示指向x参数的“指针” 而非地址，
		当&x 被强转成unsigned char * 的指向1字节序列的指针类型时，它的值即指向参数的最低字节地址
		（其他指针类型不是1字节大小时，无法指向最低字节地址）
		（指针）
		
	void 类型指针字节大小与系统字长寻址有关，64位系统时，void字节大小为8字节
	（16位系统字长2字节、32位4字节、64位8字节）
	
	show_bytes((bytes_pointer) &x,sizeof(int)): 
		&x：表示创建了一个指向保存变量x的位置指针，类型取决于传入的参数类型，之后被强转unsigned char*类型，强转类型不会改变真实的指针，只是以新的类型看待被指向的数据。
	
	总结：1.不同类型指针指向不同的字节数（单次）
		  2.机器的大小端差别
		  3.机器的字长差别
		  4.不同的数据类型有不同的位字节表示数值方式
		
	int val = 0x87654321;	//直接在地址上分配数值：87 65 43 21 （共4字节）

	C语言的字符串：
		字符串为：由结尾为null的字符数组
		字符由ASCII表示，十进制的数字由0x3x开始的16进制表示，结束符16进制为0x00
		库函数strlen（string）返回字符串字节数，不计算终止空字符
		
	
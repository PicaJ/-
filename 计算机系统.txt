计算机系统：
	type *x = a：	//a为数值类型变量
		（x的地址不是a的地址）
		*x表示为指向的值（操作数为指向值，作参数传入时，传值的拷贝）；
		&x表示为指针x的地址（操作数为地址值，作参数传入时，作地址的拷贝）；
		x+1/x[i]表示为地址的下一个数据单元（当为单字节指针时表示下一个字节地址）；
		
	type *x;
	x = &a;
		（x的地址为a的地址）
		x表示为指向的值（操作数为指向值，作参数传入时，传值的拷贝）；
		&x表示为变量a的地址（操作数为地址值，作参数传入时，作地址的拷贝）；
		x+1/x[i]表示为地址的下一个数据单元（当为单字节指针时表示下一个字节地址）；
	
	--------------------------------------------------------------------------------------------上述待修改，有错误
	每种数据类型都有它的字节长度;
		同时，每种数据类型都按其字节位表示数值	
		//int ：01 	00 	00 	00 （在小端机器上，int 1的地址分配表示的数值）（单字节表示）
		地址	0x01 0x02 0x03 0x04
		
	每个类型变量都有它的起始地址和字节长度;
	
	&x 表示指向x参数的“指针” 而非地址，
		当&x 被强转成unsigned char * 的指向1字节序列的指针类型时，它的值即指向参数的最低字节地址
		（其他指针类型不是1字节大小时，无法指向最低字节地址）
		（指针）
		
	void 类型指针字节大小与系统字长寻址有关，64位系统时，void字节大小为8字节
	（16位系统字长2字节、32位4字节、64位8字节）
	
	show_bytes((bytes_pointer) &x,sizeof(int)): 
		&x：表示创建了一个指向保存变量x的位置指针，类型取决于传入的参数类型，之后被强转unsigned char*类型，强转类型不会改变真实的指针，只是以新的类型看待被指向的数据。
	
	总结：1.不同类型指针指向不同的字节数（单次）
		  2.机器的大小端差别
		  3.机器的字长差别
		  4.不同的数据类型有不同的位字节表示数值方式
		
	int val = 0x87654321;	//直接在地址上分配数值：87 65 43 21 （共4字节）

	C语言的字符串：
		字符串为：由结尾为null的字符数组
		字符由ASCII表示，十进制的数字由0x3x开始的16进制表示，结束符16进制为0x00
		库函数strlen（string）返回字符串字节数，不计算终止空字符
	
	有符号和无符号：
	
		*非特别声明，所有的数值为有符号。
		
		有符号值位表示：
			在不同的数据位中，以最高位是否为1判断是否为负数
				1 1 1 1 ：以4位数据为例，转十进制为 -1
		
		有符号与无符号的类型强转：
			位的数值不变，理解位的方式改变，即最高位是否为负数位数值，非堆成的最终结果不一致
			
		*两者混合运算时，会将有符号转无符号（对标准运算影响不大，逻辑运算非直观）
		
		*溢出值：当整形运算出现溢出时，其值为溢出值🔺
		
		
		
		
	位左/右移：
		左移：均丢弃k位，右端空缺补0
		右移：
			（无符号必须）逻辑右移：丢弃右端，左端补0
			（多为有符号）算数右移：丢弃右端，左端按最高位补位（1时补1；0时补0）
	
	数据类型强转：
		小位转大位：高位扩展补0，有符号按最高位扩展位；
		大位转小位：高位截断
	
	
----------------------------------------程序机器级表示-------------------------------------------------------------------------------------
机器代码的内存表示为一个数组；

机器代码不区分数据类型；

十六位表示一个‘字’，大小为2个字节；

x86-64有16个通用寄存器，

机器指令，操作数指示符有三种：$立即数（直接使用$后的数值）、寄存器（R[ra]为ra寄存器对应的值）、内存引用（M[addr]，其中M[R[ra]]表示
对R[ra]的值进行地址访问，先将R[ra]转换，再将其值作地址访问）

gcc反汇编指令mov-类型：
	1.指令后缀名：
		需要考虑：
			1）操作数和目的寄存器的大小和类型，当为扩展时使用movs/movz，截断时使用mov；
			2）其中，有符号扩展时为movs，无符号扩展为movz
	
	2.操作数和目的数：
		当为指针时，无须考虑其寄存器的部位（%al、%ax、%eax、%rax等），直接寻址即可。（%rax）代表某指针的地址
	
	3.扩展/截断（类型转换）存放位置：
		扩展/截断时，把操作数存入适配的寄存器部位；
			扩展时选择扩展到目的大小的寄存器部位（如%eax等），截断时直接选择当前大小部位	

指针操作符‘ * ’：
	long x = *xp;
		*在等式右边时，为读取xp指向的值
		
	*xp = x;
		*在等式左边时，为写入xp指向的值
		
	long a = 10；&a
		&为取址操作，将创建一个指针，指向局部变量a的值，直接影响a的值



















	